#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <locale.h>
#include <math.h>

// Максимальный размер кольцевой очереди
#define MAX_BUCKET_SIZE 100

// Структура кольцевой очереди
typedef struct {
    long long data[MAX_BUCKET_SIZE];
    int head;
    int tail;
} CircularQueue;

// Инициализация кольцевой очереди (4 операции)
void init_queue(CircularQueue* q) {
    q->head = 1; // присваивание и обращение (2 операции)
    q->tail = 1; // присваивание и обращение (2 операции)
}

// Проверка на пустоту очереди (3 операции)
int is_empty(CircularQueue* q) {
    return q->head == q->tail; // обращение к структуре (2) и сравнение (3 операции)
}

// Проверка на полноту очереди (5 операций)
int is_full(CircularQueue* q) {
    return (q->tail % (MAX_BUCKET_SIZE - 1)) + 1 == q->head; // обращение (2), остаток от деления, сложение, сравнение (5 операций)
}

// Добавление элемента в кольцевую очередь (14 операций)
void in_queue(CircularQueue* q, long long value) {
    if (!is_full(q)) { // Проверка на место в очереди
        //вызов функции и отрицание (2 операции, но сама функция содержит 5 операций, те всего будет 7 операций)
        q->data[q->tail] = value; // Вставка нового элемента
        //обращение (2) и присваивание (3 операции)
        q->tail = (q->tail % (MAX_BUCKET_SIZE - 1)) + 1; // Обновляем конец 
        // обращение, остаток от деления, сложение, присваивание (4 операции)
    }
    else { // Вывод ошибки, если нет места в очереди
        wprintf(L"Ошибка: очередь переполнена, невозможно добавить %lld\n", value);
    }
}
//при успешном добавлении элемента сложность равна 14, иначе - 8

// Извлечение элемента из кольцевой очереди (13 операций)
long long from_queue(CircularQueue* q) {
    if (!is_empty(q)) { // Проверяем, что очередь не пустая
        //вызов функции и отрицание (2 операции, но сама функция содержит 3 операции, те всего будет 5 операций)
        long long value = q->data[q->head]; // Извлекаем значение с позиции head
        //обращение (2) и присваивание (3 операции)
        q->head = (q->head % (MAX_BUCKET_SIZE - 1)) + 1; // Сдвигаем
        // обращение, остаток от деления, сложение, присваивание (4 операции)
        return value; // (1 операция)
    }
    else {
        wprintf(L"Ошибка: очередь пуста, извлечение невозможно\n");
        return -1; // (1 операция)
    }
}
// при успешном извлечении элемента сложность равна 13, иначе - 6

// Размер очереди (7 операций)
int queue_size(CircularQueue* q) {
    if (q->head > q->tail) // обращение (2) и сравнение (3 операции)
        return (MAX_BUCKET_SIZE - 1) - q->head + q->tail; // обращение (2), сложение, вычитание (4 операции)
    else
        return q->tail - q->head; // обращение (2) и вычитание (3 операции)
}
// в первом случае сложность равна 7, во втором - 6

// Функция для получения цифры в разряде (3 операции)
int get_digit(long long number, long long digit) {
    return (llabs(number) / digit) % 10; // модуль, деление, остаток от деления (3 операции)
}

// Функция для нахождения максимальной длины числа в кольцевой очереди (21 + 3*x*size + 70*size операций)
int find_max_len(CircularQueue* q) {
    int max_len = 0; // присваивание (1 операция)
    int size = queue_size(q); // присваивание и вызов функции из 7 операций (9 операций)
    CircularQueue temp_queue; // Временная очередь (1 операция)
    init_queue(&temp_queue); // вызов функции из 4 операций (5 операций)

    // Временно сохраняем числа из очереди
    for (int i = 0; i < size; i++) { // присваивание (1 операция), сравнение (1 операция size+1 раз), увеличение счетчика (2 операции size раз)
        long long num = from_queue(q); // Достаем число из очереди
        // присваивание, функция из 13 операций (15 операций)
        in_queue(&temp_queue, num); // функция из 14 операций (15 операций)

        int len = 0; // присваивание (1 операция)
        long long abs_num = llabs(num); // приcваивание, модуль (2 операции)

        // x - число разрядов
        while (abs_num > 0) { // Проверяем длину, сравнение (1 операция x+1 раз)
            len++; // увеличение (1 операция x раз)
            abs_num /= 10; // деление (1 операция x раз)
        }

        // Сохраняем максимальную длину (2 операции)
        if (len > max_len) { // сравнение (1 операция)
            max_len = len; // присваивание (1 операция)
        }
    }

    // Восстанавливаем исходную очередь 
    for (int i = 0; i < size; i++) { // присваивание (1 операция), сравнение (1 операция size+1 раз), увеличение счетчика (2 операции size раз)
        long long num = from_queue(&temp_queue); // присваивание и вызов функции из 13 операций (14 операций)
        in_queue(q, num); // функция из 14 операций (14 операций)
    }

    return max_len; // 1 операция
} // 1 + 9 + 1 + 5 + 1 + size+1 + 2*size + 15*size + 15*size + size + 2*size + (3*x + 1)*size + 2*size + 1 + size+1 + 2*size + 14*size + 14*size + 1 = 21 + 3*x*size + 70*size

// Функция для распределения чисел по кучам в зависимости от разряда (11 + 38*size)
void to_buckets(CircularQueue* q, long long digit, CircularQueue buckets[10]) {
    int size = queue_size(q); // присваивание и вызов функции из 7 операций (9 операций)
    for (int i = 0; i < size; i++) { // присваивание (1 операция), сравнение (1 операция size+1 раз), увеличение счетчика (2 операции size раз)
        // проходимся по очереди и распределяем числа по кучкам (от 0 до 9) в зависимости от цифры в разряде
        long long num = from_queue(q); // присваивание и вызов функции из 13 операций (15 операций)
        int bucket_index = get_digit(num, digit); // присваивание и вызов функции из 3 операций (5 операций)
        in_queue(&buckets[bucket_index], num); //вызов функции из 14 операций (15 операций)
    }
} // 9 + 1 + size+1 + 2*size + 15*size + 5*size + 15*size = 11 + 38*size

// Функция для сбора чисел из куч обратно в исходную очередь  (82 + 350*size операций)
void from_buckets(CircularQueue* q, CircularQueue buckets[10]) {
    for (int i = 0; i < 10; i++) { // присваивание (1 операция), сравнение (1 операция 11 раз), увеличение счетчика (2 операции 10 раз)
        while (!is_empty(&buckets[i])) { // вызов функции из 3 операций, отрицание, сравнение (6 операций size+1 раз)
            long long num = from_queue(&buckets[i]); // Возвращаем число из кучи обратно в очередь
            // присваивание, вызов функции из 13 операций (15 операций size раз)
            in_queue(q, num); // вызов функции из 14 операций (15 операций size раз)
        }
    }
} // 1 + 11 + 20 + 10*(5*(size+1) + 15*size + 15*size) = 32 + 50*size + 50 + 150*size + 150*size = 82 + 350*size

// Распределяющая (лексикографическая) сортировка (326*size + 782*size*x + 283*x + 99 операций)
void distributing_sort(CircularQueue* q) {
    // Создадим очереди для положительных и отрицательных чисел
    CircularQueue positive_numbers, negative_numbers; // 2 операции
    init_queue(&positive_numbers); // вызов функции из 4 операций (5 операций)
    init_queue(&negative_numbers); // вызов функции из 4 операций (5 операций)

    // Разделение на положительные и отрицательные
    int size = queue_size(q); // присваивание и вызов функции из 7 операций (9 операций)
    for (int i = 0; i < size; i++) { // присваивание (1 операция), сравнение (1 операция size+1 раз), увеличение счетчика (2 операции size раз)
        long long num = from_queue(q); // присваивание и вызов функции из 13 операций (15 операций)
        if (num < 0) { // сравнение (1 операция)
            in_queue(&negative_numbers, num); // вызов функции из 14 операций (15 операций)
        }
        else {
            in_queue(&positive_numbers, num); // вызов функции из 14 операций (15 операций)
        }
    }

    // Сортировка положительных чисел
    int max_len = find_max_len(&positive_numbers); // Нахождение максимальной длины числа
    // присваивание и вызов функции из 21 + 3*x*size + 70*size операций (23 + 3*x*size + 70*size операций)
    long long digit = 1; // присваивание (1 операция)

    for (int i = 0; i < max_len; i++) { // присваивание (1 операция), сравнение (1 операция max_len+1 раз), увеличение счетчика (2 операции max_len раз)
        CircularQueue buckets[10]; // 10 кольцевых очередей для 10 цифр (1 операция)
        for (int i = 0; i < 10; i++) { // присваивание (1 операция), сравнение (1 операция 11 раз), увеличение счетчика (2 операции 10 раз)
            init_queue(&buckets[i]); // вызов функции из 4 операций (5 операций)
        }
        to_buckets(&positive_numbers, digit, buckets); // Распределяем по кучам
        //вызов функции из 11 + 38*size операций (12 + 38*size операций)
        from_buckets(&positive_numbers, buckets); // Собираем обратно в одну очередь
        // вызов функции из 82 + 350*size операций (83 + 350*size операций)
        digit *= 10; // Переход к следующему разряду (2 операции)
    }

    // Сортировка отрицательных чисел по модулю
    max_len = find_max_len(&negative_numbers); // присваивание и вызов функции из из 21 + 3*x*size + 70*size операций (23 + 3*x*size + 70*size операций)
    digit = 1; // присваивание (1 операция)

    for (int i = 0; i < max_len; i++) { // присваивание (1 операция), сравнение (1 операция max_len+1 раз), увеличение счетчика (2 операции max_len раз)
        CircularQueue buckets[10]; // 10 кольцевых очередей для 10 цифр
        for (int i = 0; i < 10; i++) { // присваивание (1 операция), сравнение (1 операция 11 раз), увеличение счетчика (2 операции 10 раз)
            init_queue(&buckets[i]); // вызов функции из 4 операций (5 операций)
        }
        to_buckets(&negative_numbers, digit, buckets); // Распределяем по кучам
        //вызов функции из 11 + 38*size операций (12 + 38*size операций)
        from_buckets(&negative_numbers, buckets); // Собираем обратно в одну очередь
        // вызов функции из 82 + 350*size операций (83 + 350*size операций)
        digit *= 10; // Переход к следующему разряду
        // присваивание и умножение (2 операции)
    }

    // Объединение отрицательных и положительных чисел
    long long temp[MAX_BUCKET_SIZE]; // 1 операция
    int neg_size = queue_size(&negative_numbers); // присваивание и вызов функции из 7 операций (9 операций)
    for (int i = 0; i < neg_size; i++) { // присваивание (1 операция), сравнение (1 операция neg_size+1 раз), увеличение счетчика (2 операции neg_size раз)
        temp[i] = from_queue(&negative_numbers); // присваивание и вызов функции из 14 операций (16 операций)
    }
    for (int i = neg_size - 1; i >= 0; i--) { // присваивание, сравнение (neg_size+1 раз), уменьшение счетчика (2 операции neg_size раз) 
        in_queue(q, temp[i]); // вызов функции из 14 операций (15 операций)
    }

    int pos_size = queue_size(&positive_numbers); // присваивание и вызов функции из 7 операций (9 операций)
    for (int i = 0; i < pos_size; i++) { // присваивание (1 операция), сравнение (1 операция pos_size+1 раз), увеличение счетчика (2 операции pos_size раз)
        in_queue(q, from_queue(&positive_numbers)); // вызов функций из 14 операций и 13 операций (29 операций)
    }
} //обозначим max_len за x (число разрядов), neg_size и pos_size за size
//2 + 5 + 5 + 9 + 1 + size + 1 + 2*size + 15*size + size + 15*size + 23 + 3*x*size + 70*size + 1 + x + 1 + 2*x + x + x + 11*x + 20*x + 50*x + 12*x + 38*x*size + 2*x + 83*x + 350*x*size + 23 + 3*x*size + 70*size + 1 + 1 + x + 1 + 2*x + x + x + 11*x + 20*x + 50*x + 12*x + 38*x*size + 83*size + 350*x*size + 2*x + 1 + 9 + 1 + size + 1 + 2*size + 16*size + 1 + size + 1 + 2*size + 15*size + 9 + 1 + size + 1 + 2*size + 29*size = 326*size + 782*size*x + 283*x + 99

// Функция для чтения чисел из файла в кольцевую очередь (17*size + 3 операций)
void read_to_queue(FILE* file, CircularQueue* q) {
    long long num; // 1 операция
    while (fscanf(file, "%lld", &num) == 1) { // сравнение и функция (2*(size+1) операций, где size - количество чисел)
        in_queue(q, num); // вызов функции из 14 операций (15 операций size раз)
    }
}

// Функция для вывода чисел из кольцевой очереди (33*size + 11 операций)
void print_queue(CircularQueue* q) {
    int size = queue_size(q); // присваивание и вызов функции из 7 операций (9 операций)
    for (int i = 0; i < size; i++) { // присваивание (1 операция), сравнение (1 операция size+1 раз), увеличение счетчика (2 операции size раз) 
        long long num = from_queue(q); // присваивание и вызов функции из 13 операций (15 операций)
        wprintf(L"%lld ", num); 
        in_queue(q, num); // Возвращаем элемент в очередь после вывода
        // вызов функции из 14 операций (15 операций)
    }
    wprintf(L"\n");
} // 9 + 1 + 1 + size + 2*size + 15*size + 15*size = 33*size + 11

int main() { 
    setlocale(LC_ALL, ""); // Для поддержки русских символов
    // вызов функции (1 операция)

    wchar_t filename[100]; // Имя файла (1 операция)
    FILE* file = NULL; // Указатель на файл (1 операция)

    // Просим пользователя ввести имя файла
    do {
        wprintf(L"Введите имя файла, в котором хранятся числа: ");
        wscanf(L"%ls", filename); // 1 операция
        file = _wfopen(filename, L"r"); // присваивание и открытие (2 операции)

        if (file == NULL) { // сравнение (1 операций)
            wprintf(L"Не удалось открыть файл. Введите имя файла повторно.\n\n");
        }
    } while (file == NULL); // сравнение (1 операция)

    // Инициализируем кольцевую очередь
    CircularQueue q; // 1 операция
    init_queue(&q); // вызов функции из 4 операций (5 операций)

    // Чтение чисел из файла в кольцевую очередь
    read_to_queue(file, &q); // вызов функции из 17*size + 3 операций (17*size + 4 операций)

    fclose(file); // закрываем файл (1 операция)

    // Вывод исходной последовательности
    wprintf(L"Исходная последовательность:\n");
    print_queue(&q); // вызов функции из 33*size + 11 операций (33*size + 12 операций)

    // Сортировка
    distributing_sort(&q); // вызов функции из 326*size + 782*size*x + 283*x + 99  операций (326*size + 782*size*x + 283*x + 100 операций)

    // Вывод отсортированной последовательности
    wprintf(L"\nОтсортированная последовательность:\n");
    print_queue(&q); // вызов функции из 33*size + 11 операций (33*size + 12 операций)

    return 0; // 1 операция
} // 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 5 + 17*size + 4 + 1 + 33*size + 12 + 326*size + 782*size*x + 283*x + 100 + 33*size + 12 + 1 = 782*size*x + 409*size + 283*x + 144
